use std::{intrinsics::copy_nonoverlapping, mem::take};

use memmap2::MmapMut;

use crate::MacroAssembler;

/// LinkBuffer:
///
///
/// This structure assists in linking code generated by the macro assembler, once code generation
/// has been completed, and the code has been copied to is final location in memory.  At this
/// time pointers to labels within the code may be resolved, and relative offsets to external
/// addresses may be fixed.
///
///
/// Specifically:
///   * Jump objects may be linked to external targets,
///   * The address of Jump objects may taken, such that it can later be relinked.
///   * The return address of a Call may be acquired.
///   * The address of a Label pointing into the code may be resolved.
///   * The value referenced by a DataLabel may be set.
///
pub struct LinkBuffer {
    size: usize,
    did_allocate: bool,
    link_tasks: Vec<Box<dyn FnOnce(&mut Self)>>,
    late_link_tasks: Vec<Box<dyn FnOnce(&mut Self)>>,
    code: usize,
    executable_memory: Option<MmapMut>,
}

impl LinkBuffer {
    pub fn allocate(&mut self, masm: &mut impl MacroAssembler) {
        let mut initial_size = masm.code_size();
        if self.code != 0 {
            if initial_size > self.size {
                return;
            }
            let nops_to_fill_in_bytes = self.size - initial_size;
            masm.emit_nops(nops_to_fill_in_bytes);
            self.did_allocate = true;
            return;
        }
        while initial_size % 32 != 0 {
            masm.breakpoint();
            initial_size = masm.code_size();
        }

        match MmapMut::map_anon(initial_size) {
            Ok(mut mmap) => {
                self.code = mmap.as_mut_ptr() as usize;
                self.size = initial_size;
                self.did_allocate = true;
                self.executable_memory = Some(mmap);
            }
            _ => return,
        }
    }

    pub fn perform_finalization(&mut self) {
        for task in take(&mut self.link_tasks) {
            task(self);
        }

        for task in take(&mut self.late_link_tasks) {
            task(self);
        }
    }

    pub fn dump_link_statistics(
        &self,
        out: &mut impl std::fmt::Write,
        code: *mut u8,
        initial_size: usize,
        final_size: usize,
    ) -> std::fmt::Result {
        write!(
            out,
            "link {:p}: orig {},compact {} (delta {}, {:.2} )\n",
            code as *mut u8,
            initial_size,
            final_size,
            initial_size - final_size,
            100.0 * (initial_size as f64 / final_size as f64) / initial_size as f64
        )?;
        Ok(())
    }

    pub fn finalize_code_without_disassembly(&mut self) -> Result<CodeRef, MmapMut> {
        self.perform_finalization();
        if let Some(mem) = self.executable_memory.take() {
            return Err(mem);
        }

        Ok(CodeRef {
            size: self.size,
            ptr: self.code as _,
        })
    }

    pub fn link_code(&mut self, masm: &mut impl MacroAssembler) {
        masm.label();

        self.allocate(masm);

        if !self.did_allocate {
            return;
        }
        unsafe {
            copy_nonoverlapping(
                masm.buffer().data.as_ptr(),
                self.code as *mut u8,
                masm.buffer().data.len(),
            );
        }
        self.link_tasks = masm.take_link_tasks();
        self.late_link_tasks = masm.take_late_link_tasks();
    }
}

pub struct CodeRef {
    pub size: usize,
    pub ptr: *mut u8,
}
